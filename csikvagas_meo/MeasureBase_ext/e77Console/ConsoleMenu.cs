using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Diagnostics;

using e77.MeasureBase;

namespace e77.MeasureBase.e77Console
{
    public class ConsoleMenu
    {
        /// <summary>
        /// Auto Key Generation: if ConsoleMenuItem.Key is not specified, but ConsoleMenu.menuStartInt_in has value, the keys will be sequentialy allocated.
        /// 
        /// Submenu Handling: 
        ///     1. save position of the parent menu ('int orgPos = Console.CursorTop;' before calling ConsoleMenu.DoMenu)
        ///     2. after submenu cwhen draw parent again
        /// </summary>
        /// <param name="preMessage_in"></param>
        /// <param name="postMessage_in"></param>
        /// <param name="noAnswareAccepted_in">return null if Escape button pressed</param>
        /// <param name="enterRequired_in"> select '1' needs '1' or '1'+Enter</param>
        /// <param name="menuStartInt_in"> used only if ConsoleMenuItem.Key is not specified. All non-secified items gets an integer ater this value. If this is null - auto Key generation is disabled: items without keys can be accessed bu arrow keys only.</param>
        /// <param name="items_in"></param>
        public ConsoleMenu(string preMessage_in, string postMessage_in, bool noAnswareAccepted_in, bool enterRequired_in, int? menuStartInt_in, IEnumerable<ConsoleMenuItem> items_in)
            : this(noAnswareAccepted_in, enterRequired_in, menuStartInt_in, items_in)
        {
            PreMessage = preMessage_in;
            PostMessage = postMessage_in;
        }

        internal ConsoleMenu(bool noAnswareAccepted_in, bool enterRequired_in, int? menuStartInt_in, IEnumerable<ConsoleMenuItem> items_in)
        {
            _noAnswareAccepted = noAnswareAccepted_in;
            _lastAutoGeneratedKey = menuStartInt_in;
            Items = new List<ConsoleMenuItem> ( items_in ).ToArray();

            int currItem = 0;
            foreach (ConsoleMenuItem item in Items) //init items:
            {
                //Auto Key Generation + set Index
                item.Index = currItem++;
                if (_lastAutoGeneratedKey.HasValue //is needed
                    && item.Key == string.Empty) //and this item needes Auto Key Generation
                {
                    item.Key = (_lastAutoGeneratedKey++).ToString();
                }

                if (item.Key != string.Empty)
                {
                    _itemsDictionary.Add(item.Key.ToLowerInvariant(), item);
                }
            }

            _enterRequired = enterRequired_in;
        }

        /// <summary>
        /// for handle multi-thread (Ctrl+C event calls in another thread)
        /// Note: du to muiltthread access this List should be protected by 'lock(_activeMenus)'.
        /// </summary>
        static List<ConsoleMenu> _activeMenus = new List<ConsoleMenu>();

        private int _startPos;

        /// <summary>
        /// clears the showed menu, and set cursor to the top (beginning of the original menu)
        /// </summary>
        public void ClearArea()
        {
            ConsoleHelper.ClearArea(_startPos, Console.CursorTop);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="selectedItem_in">index of selectred item</param>
        /// <param name="startYPos_in">if specified: Console.CursorTop of menu (area cleared if smaller than current cursor position) </param>
        /// <returns></returns>
        public ConsoleMenuItem DoMenu(int? selectedItem_in, int? startYPos_in)
        {
            lock(_activeMenus)
                _activeMenus.Add(this);

            try
            {
                Trace.TraceInformation("ConsoleMenuItem.DoMenu(). Object: {0}.", this);

                _startPos = Console.CursorTop;

                if (_selectedItem.HasValue && _selectedItem.Value >= Items.Length)
                    throw new ArgumentException(string.Format("Invalid defaultItem_in ({0}). Number of items: {1}",
                        selectedItem_in.Value, Items.Length));

                if (startYPos_in.HasValue && startYPos_in.Value != Console.CursorTop)
                {
                    if (startYPos_in < Console.CursorTop)
                        ConsoleHelper.ClearArea(startYPos_in.Value, Console.CursorTop);
                    else
                        Console.CursorTop = startYPos_in.Value;

                    Console.CursorLeft = 0;
                }

                _selectedItem = selectedItem_in;

                while (Console.KeyAvailable) 
                    Console.ReadKey();

                if (PreMessage != null && PreMessage != string.Empty)
                    Console.WriteLine(PreMessage);

                int cursorTop = Console.CursorTop;
                string currentCommand = string.Empty;

                do
                {
                    Console.CursorTop = cursorTop; //reset origin
                    Console.CursorLeft = 0;
                    ShowMenu();

                    if (PostMessage != null && PostMessage != string.Empty)
                        Console.WriteLine(PostMessage);

                    Console.Write(">{0}{1}", currentCommand, EMPTY_STR);//last ' ' is for new command char (overwrite old one)
                    Console.CursorLeft -= EMPTY_STR.Length;

                    bool isMeActive;//this is at the end of the list
                    ConsoleKeyInfo ki;

                    //wait until other (e.g.cancel) thread active
                    while (true)
                    {
                        lock(_activeMenus)
                            isMeActive = _activeMenus[_activeMenus.Count - 1] == this;

                        if (!isMeActive)
                            continue;

                        ki = Console.ReadKey();

                        //check if active state losed during ReadKey()
                        lock (_activeMenus)
                            isMeActive = _activeMenus[_activeMenus.Count - 1] == this;

                        if (isMeActive)
                            break;
                    }
                    
                    if (ki.Key == ConsoleKey.UpArrow)
                    {
                        if (_selectedItem.HasValue && (_selectedItem > 0))
                            _selectedItem--;
                        else
                            _selectedItem = Items.Length - 1;

                        currentCommand = Items[_selectedItem.Value].Key;
                    }
                    else if (ki.Key == ConsoleKey.DownArrow)
                    {
                        currentCommand = string.Empty;
                        if (_selectedItem.HasValue && (_selectedItem < Items.Length - 1))
                            _selectedItem++;
                        else
                            _selectedItem = 0;

                        currentCommand = Items[_selectedItem.Value].Key;
                    }
                    else if (ki.Key == ConsoleKey.Escape)
                    {
                        currentCommand = string.Empty;
                        if (_noAnswareAccepted)
                        {
                            Console.CursorLeft = 0;
                            Console.WriteLine();

                            Trace.TraceInformation("Válaszott elem: {null}");
                            return null;
                        }
                    }
                    else if (ki.Key == ConsoleKey.Enter || ki.Key == ConsoleKey.Spacebar)
                    {
                        if (_selectedItem.HasValue)
                            break;
                    }
                    if (ki.Key == ConsoleKey.LeftArrow || ki.Key == ConsoleKey.Backspace)
                    {
                        if (currentCommand.Length > 0)
                        {
                            currentCommand = currentCommand.Substring(0, currentCommand.Length - 1);

                            if (_itemsDictionary.ContainsKey(currentCommand))
                                _selectedItem = _itemsDictionary[currentCommand].Index;
                        }
                    }
                    else if (char.IsLetterOrDigit(ki.KeyChar))
                    {
                        //is valid key:
                        char currCharToLower = char.ToLowerInvariant(ki.KeyChar);
                        string newCommand = string.Format("{0}{1}", currentCommand, currCharToLower);

                        string newItemKey = _itemsDictionary.Keys.FirstOrDefault(item => item.StartsWith(newCommand));
                        if (newItemKey != null)
                        {
                            currentCommand = newCommand;
                            _selectedItem = _itemsDictionary[newItemKey].Index;

                            //no enter needed and exact match:
                            if (!_enterRequired && currentCommand == newItemKey
                                && currentCommand == _itemsDictionary.Keys.Last(item => item.StartsWith(currentCommand))) //there is not other item with this prefix
                            {
                                break;
                            }
                        }

                        //no enter req. and same valid command arrived (selected by arrow, and pressed the key now)
                        if (newItemKey == null && !_enterRequired && currentCommand.Length == 1 && currentCommand[0] == currCharToLower)
                        {
                            break;
                        }
                    }

                } while (true);//leave this only if _defaultItem.HasValue currentCommand is valid   

                Console.CursorLeft = 0;
                Console.WriteLine();

                ConsoleMenuItem selectedItem = Items[_selectedItem.Value];

                Trace.TraceInformation("Válaszott elem: {0}", selectedItem);

                if (selectedItem.DoWorkCallback != null)
                    selectedItem.DoWorkCallback();

                return selectedItem;
            }
            finally
            {
                ConsoleMenu cm;
                lock(_activeMenus)
                    cm = _activeMenus[_activeMenus.Count - 1];

                if (cm != this)
                    throw new MeasureBaseInternalException("console multithread inconsistency {0} vs. {1}", this, cm);

                lock(_activeMenus)
                    _activeMenus.RemoveAt(_activeMenus.Count - 1);
            }
        }

        public void ShowMenu()
        {
            int maxKeyLenght = Items.Max(item => item.Key.Length);
            int currItem = 0;
            foreach (ConsoleMenuItem item in Items)
            {
                item.Show(_selectedItem.HasValue && _selectedItem.Value == currItem, maxKeyLenght + 2);

                currItem++;
            }
        }

        public string PreMessage { get; set; }
        public string PostMessage { get; set; }


        public override string ToString()
        {
            return string.Format("{0}, Items: {1}", PreMessage, Items.ItemsToString());
        }

        const string EMPTY_STR = "                     ";

        bool _noAnswareAccepted;
        bool _enterRequired;
        public ConsoleMenuItem[] Items { get; private set; }

        /// <summary>
        /// Note: This collection does not contains items without keys!
        /// Key: command.ToLover()
        /// </summary>
        SortedDictionary<string, ConsoleMenuItem> _itemsDictionary = new SortedDictionary<string, ConsoleMenuItem>();

        int? _selectedItem;
        int? _lastAutoGeneratedKey; // todo_fgy is needed as member, or local enought. if more than 9, integer selection needed
    }
}